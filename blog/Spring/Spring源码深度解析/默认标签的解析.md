## 默认标签的解析

默认标签的解析是在parseDefaultElement函数中进行的，函数中的功能逻辑一目了然，分别对4种不同标签（import、alias、bean和beans）做了不同的处理。

```java
	private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
//		对import标签的处理
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
//		对alias标签的处理
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
//		对bean标签的处理
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
//		对beans标签的处理
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
```

### bean标签的解析及注册

在4种标签的解析中，对bean标签的解析最为复杂也最为重要。首先我们进入函数processBeanDefinition(ele, delegate)。

```java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
   if (bdHolder != null) {
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try {
         // Register the final decorated instance.
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error("Failed to register bean definition with name '" +
               bdHolder.getBeanName() + "'", ele, ex);
      }
      // Send registration event.
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   }
}
```

大致的逻辑总结如下。

1．首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class、name、id、alias之类的属性。

2．当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。

3．解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了Bean- DefinitionReaderUtils的registerBeanDefinition方法。

4．最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。

配合时序图，可能会更容易理解。

![](D:/Private/MyGit/blog/Spring/Spring源码深度解析/NeatReader-1595769674813.png)

#### 解析BeanDefinition

我们从元素解析及信息提取开始，也就是

~~~java
BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele)
~~~

进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法

```java
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
   return parseBeanDefinitionElement(ele, null);
}
```

```java
    public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
//    解析id属性
      String id = ele.getAttribute(ID_ATTRIBUTE);
//    解析name属性
      String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

//    分割name属性
      List<String> aliases = new ArrayList<>();
      if (StringUtils.hasLength(nameAttr)) {
         String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
         aliases.addAll(Arrays.asList(nameArr));
      }

      String beanName = id;
      if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
         beanName = aliases.remove(0);
         if (logger.isTraceEnabled()) {
            logger.trace("No XML 'id' specified - using '" + beanName +
                  "' as bean name and " + aliases + " as aliases");
         }
      }

      if (containingBean == null) {
         checkNameUniqueness(beanName, aliases, ele);
      }

      AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
      if (beanDefinition != null) {
         if (!StringUtils.hasText(beanName)) {
            try {
//             如果不存在beanName那么根据Spring提供的命名规则为当前bean生成对应的beanName
               if (containingBean != null) {
                  beanName = BeanDefinitionReaderUtils.generateBeanName(
                        beanDefinition, this.readerContext.getRegistry(), true);
               }
               else {
                  beanName = this.readerContext.generateBeanName(beanDefinition);
                  // Register an alias for the plain bean class name, if still possible,
                  // if the generator returned the class name plus a suffix.
                  // This is expected for Spring 1.2/2.0 backwards compatibility.
                  String beanClassName = beanDefinition.getBeanClassName();
                  if (beanClassName != null &&
                        beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                     aliases.add(beanClassName);
                  }
               }
               if (logger.isTraceEnabled()) {
                  logger.trace("Neither XML 'id' nor 'name' specified - " +
                        "using generated bean name [" + beanName + "]");
               }
            }
            catch (Exception ex) {
               error(ex.getMessage(), ele);
               return null;
            }
         }
         String[] aliasesArray = StringUtils.toStringArray(aliases);
         return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
      }

      return null;
   }
```

在开始对属性展开全面解析前，Spring在外层又做了一个当前层的功能架构，在当前层完成的主要工作包括如下内容。

1．提取元素中的id以及name属性。

2．进一步解析其他所有属性并统一封装至GenericBeanDefinition类型的实例中。

3．如果检测到bean没有指定beanName，那么使用默认规则为此Bean生成beanName。

4．将获取到的信息封装到BeanDefinitionHolder的实例中。

我们进一步地查看步骤2中对标签其他属性的解析过程

```java
public AbstractBeanDefinition parseBeanDefinitionElement(
      Element ele, String beanName, @Nullable BeanDefinition containingBean) {

   this.parseState.push(new BeanEntry(beanName));

   String className = null;
   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
   }
   String parent = null;
   if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
      parent = ele.getAttribute(PARENT_ATTRIBUTE);
   }

   try {
      AbstractBeanDefinition bd = createBeanDefinition(className, parent);

      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

      parseMetaElements(ele, bd);
      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

      parseConstructorArgElements(ele, bd);
      parsePropertyElements(ele, bd);
      parseQualifierElements(ele, bd);

      bd.setResource(this.readerContext.getResource());
      bd.setSource(extractSource(ele));

      return bd;
   }
   catch (ClassNotFoundException ex) {
      error("Bean class [" + className + "] not found", ele, ex);
   }
   catch (NoClassDefFoundError err) {
      error("Class that bean class [" + className + "] depends on not found", ele, err);
   }
   catch (Throwable ex) {
      error("Unexpected failure during bean definition parsing", ele, ex);
   }
   finally {
      this.parseState.pop();
   }

   return null;
}
```

1. 创建用于属性承载的BeanDefinition

   BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition、ChildBean-Definition以及GenericBeanDefinition。三种实现均继承了AbstractBeanDefiniton，其中BeanDefinition是配置文件\<bean>元素标签在容器中的内部表示形式。

   \<bean>元素标签拥有class、scope、lazy-init等配置属性，BeanDefinition则提供了相应的beanClass、scope、lazyInit属性，BeanDefinition和\<bean>中的属性是一一对应的。其中RootBeanDefinition是最常用的实现类，它对应一般性的\<bean>元素标签，GenericBeanDefinition是自2.5版本以后新加入的bean文件配置属性定义类，是一站式服务类。

   在配置文件中可以定义父\<bean>和子\<bean>，父\<bean>用RootBeanDefinition表示，而子\<bean>用ChildBeanDefiniton表示，而没有父\<bean>的\<bean>就使用RootBeanDefinition表示。AbstractBeanDefinition对两者共同的类信息进行抽象。

   Spring通过BeanDefinition将配置文件中的\<bean>配置信息转换为容器的内部表示，并将这些BeanDefiniton注册到BeanDefinitonRegistry中。Spring容器的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息。它们之间的关系如图所示。

   ![image-20200726220338770](/Users/q/Documents/Code/Github/MyGit/blog/Spring/Spring源码深度解析/image-20200726220338770.png)

   由此可知，要解析属性首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition类型的实例。而代码createBeanDefinition(className, parent)的作用就是实现此功能。

   ```java
   protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
         throws ClassNotFoundException {
   
      return BeanDefinitionReaderUtils.createBeanDefinition(
            parentName, className, this.readerContext.getBeanClassLoader());
   }
   ```

   继续查看BeanDefinitionReaderUtils的createBeanDefinition方法

   ~~~java
   	public static AbstractBeanDefinition createBeanDefinition(
   			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {
   
   		GenericBeanDefinition bd = new GenericBeanDefinition();
   //		parentName可能为空
   		bd.setParentName(parentName);
   		if (className != null) {
   			if (classLoader != null) {
   //				如果classLoader不为空，则使用已传入的classLoader加载类对象，否则只是记录className
   				bd.setBeanClass(ClassUtils.forName(className, classLoader));
   			}
   			else {
   				bd.setBeanClassName(className);
   			}
   		}
   		return bd;
   	}
   ~~~

2. 解析各种属性

   创建了bean信息的承载实例后，便可以进行bean信息的各种属性解析了，首先我们进入parseBeanDefinitionAttributes方法。parseBeanDefinitionAttributes方法是对element所有元素属性进行解析：

   ```java
       public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
            @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
   
   //    如果有singleton属性则提示错误日志
         if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
            error("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);
         }
   //    解析scope属性
         else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
         }
         else if (containingBean != null) {
   //       在嵌入beanDefinitino其况下没有单独指定scope属性则使用父类默认的属性
            // Take default from containing bean in case of an inner bean definition.
            bd.setScope(containingBean.getScope());
         }
   
   //    解析abstract属性
         if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
         }
   
   //    解析lazy-init属性
         String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
         if (isDefaultValue(lazyInit)) {
            lazyInit = this.defaults.getLazyInit();
         }
   //    没有设置或设置成其他字符都被设置为false
         bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
   
   //    解析autowire属性
         String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
         bd.setAutowireMode(getAutowireMode(autowire));
   
   //    解析dependency-on属性
         if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
            String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
         }
   
   //    解析autowire-candidate属性
         String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
         if (isDefaultValue(autowireCandidate)) {
            String candidatePattern = this.defaults.getAutowireCandidates();
            if (candidatePattern != null) {
               String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
               bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
            }
         }
         else {
            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
         }
   
   //    primary属性
         if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
         }
   
   //    init-method属性
         if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
            String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
            bd.setInitMethodName(initMethodName);
         }
         else if (this.defaults.getInitMethod() != null) {
            bd.setInitMethodName(this.defaults.getInitMethod());
            bd.setEnforceInitMethod(false);
         }
   
   //    destroy-method属性
         if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
            String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
            bd.setDestroyMethodName(destroyMethodName);
         }
         else if (this.defaults.getDestroyMethod() != null) {
            bd.setDestroyMethodName(this.defaults.getDestroyMethod());
            bd.setEnforceDestroyMethod(false);
         }
   
   //    factory-method属性
         if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
         }
   //    factory-bean属性
         if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
         }
   
         return bd;
      }
   ```

3. 解析子元素meta

   回顾下meta属性的使用:

   ~~~xml
   <bean id="myTestBean" class="top.hellooooo.sourcecode.charpter02.bean.MyTestBean">
   	<meta key="testStr" value="aaaaaa"/>
   </bean>
   ~~~

   这段代码并不会体现在MyTestBean的属性当中，而是一个额外的声明，当需要使用里面的信息的时候可以通过BeanDefinition的getAttribute(key)方法进行获取。

4. 解析子元素lookup-method

   同样，子元素lookup-method似乎并不是很常用，但是在某些时候它的确是非常有用的属性，通常我们称它为获取器注入。引用*Spring in Action* 中的一句话：获取器注入是一种特殊的方法注入，它是把一个方法声明为返回某种类型的bean，但实际要返回的bean是在配置文件里面配置的，此方法可用在设计有些可插拔的功能上，解除程序依赖。我们看看具体的应用。

   首先创建一个父类User

   ~~~java
   public class User {
   
        public void showMe(){
            System.out.println("i am user");
        }
   }
   ~~~

   创建子类覆盖showMe方法

   ```java
   public class Teacher extends User{
        public void showMe(){
                System.out.println("i am Teacher");
        }
   }
   ```

   创建抽象类调用方法

   ```java
   public abstract class GetBeanTest {
   
        public void showMe(){
            this.getBean().showMe();
        }
        public abstract User getBean();
   }
   ```

   创建测试方法

    ~~~java
   import org.Springframework.context.ApplicationContext;
   import org.Springframework.context.support.ClassPathXmlApplicationContext;
   import test.lookup.app.GetBeanTest;
   
   public class Main {
        public static void main(String[] args) {
            ApplicationContext bf = 
                    new ClassPathXmlApplicationContext("lookup.xml"); 
            GetBeanTest test=(GetBeanTest) bf.getBean("getBeanTest");
            test.showMe();
        }
   }
    ~~~

   很明显还缺少配置文件:

   ~~~xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
   	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   	   xmlns:context="http://www.springframework.org/schema/context"
   	   xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd">
   	<bean id="getBeanTest" class="top.hellooooo.sourcecode.charpter02.test.lookup.GetBeanTest">
   		<lookup-method name="getBean" bean="teacher"/>
   	</bean>
   	<bean id="teacher" class="top.hellooooo.sourcecode.charpter02.bean.Teacher"/>
   </beans>
   ~~~

   运行之后，打印

    ~~~
   i am Teacher
    ~~~

   如果业务变更，teacher中的业务逻辑不符合要求了，需要进行替换，替换成如下逻辑类

   ~~~java
   public class Student extends User {
   
        public void showMe(){
            System.out.println("i am student");
        }
   }
   ~~~

   修改配置文件:

   ~~~xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
   	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   	   xmlns:context="http://www.springframework.org/schema/context"
   	   xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd">
   
   	<bean id="getBeanTest" class="top.hellooooo.sourcecode.charpter02.test.lookup.GetBeanTest">
   		<lookup-method name="getBean" bean="student"/>
   	</bean>
   
   	<bean id="student" class="top.hellooooo.sourcecode.charpter02.bean.Student"/>
   	<bean id="teacher" class="top.hellooooo.sourcecode.charpter02.bean.Teacher"/>
   </beans>
   ~~~

   结果：

   ~~~
   i am Student
   ~~~

   looup-method解析：

   ```java
       public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
         NodeList nl = beanEle.getChildNodes();
         for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
   //       仅当在Spring默认bean的子元素下且为 <lookup-method时有效
            if (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
               Element ele = (Element) node;
   //          获取要修饰的方法名
               String methodName = ele.getAttribute(NAME_ATTRIBUTE);
   //          获取配置返回的bean
               String beanRef = ele.getAttribute(BEAN_ELEMENT);
               LookupOverride override = new LookupOverride(methodName, beanRef);
               override.setSource(extractSource(ele));
               overrides.addOverride(override);
            }
         }
      }
   ```

   上面的代码很眼熟，似乎与parseMetaElements的代码大同小异，最大的区别就是在if判断中的节点名称在这里被修改为LOOKUP_METHOD_ELEMENT。还有，在数据存储上面通过使用LookupOverride类型的实体类来进行数据承载并记录在AbstractBeanDefinition中的methodOverrides属性中。

5. 解析子元素replaced-method

   方法替换：可以在运行时用新的方法替换现有的方法。与之前的look-up不同的是，replaced-method不但可以动态地替换返回实体bean，而且还能动态地更改原有方法的逻辑。我们来看看使用示例。

   1.在changeMe中完成某个业务逻辑

   ```java
   public class TestChangeMethod {
   
        public void changeMe(){
                System.out.println("changeMe");
        }
   }
   ```

   2.运行一段时间后需要改变原来的逻辑

   ```java
   public class TestMethodReplacer implements MethodReplacer {
      @Override
      public Object reimplement(Object obj, Method method, Object[] args)throws Throwable {
          System.out.println("我替换了原有的方法");
          return null;
      }
   }
   ```

   3.使替换后的类生效

   ~~~xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
   	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   	   xmlns:context="http://www.springframework.org/schema/context"
   	   xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd">
   
   	<bean class="top.hellooooo.sourcecode.charpter02.test.replace.TestChangeMethod">
   		<replaced-method name="changeMe" replacer="replacer"/>
   	</bean>
   
   	<bean class="top.hellooooo.sourcecode.charpter02.test.replace.TestMethodReplacer" id="replacer"></bean>
   </beans>
   ~~~

   测试:

   ~~~java
   		ApplicationContext context = new ClassPathXmlApplicationContext("replace.xml");
   		TestChangeMethod testChangeMethod = (TestChangeMethod) context.getBean("testChangeMethod");
   		testChangeMethod.changeMe();
   ~~~

   源码：

   ```java
   public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
         NodeList nl = beanEle.getChildNodes();
         for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
   //       仅当Spring默认bean的子元素下且为<replace-method时方法有效
            if (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
               Element replacedMethodEle = (Element) node;
   //          提取要替换的旧的方法
               String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
   //          提取对应的替换方法
               String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
               ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
               // Look for arg-type match elements.
               List<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
               for (Element argTypeEle : argTypeEles) {
   //             记录参数
                  String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
                  match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
                  if (StringUtils.hasText(match)) {
                     replaceOverride.addTypeIdentifier(match);
                  }
               }
               replaceOverride.setSource(extractSource(replacedMethodEle));
               overrides.addOverride(replaceOverride);
            }
         }
      }
   ```

   我们可以看到无论是look-up还是replaced-method都是构造了一个MethodOverride，并最终记录在了AbstractBeanDefinition中的methodOverrides属性中。

6. 解析子元素constructor-arg

   例如：

   ~~~xml
   <!-- 默认的情况下是按照参数的顺序注入，当指定index索引后就可以改变注入参数的顺序 -->  
       <bean id="helloBean" class="com.HelloBean">  
           <constructor-arg index="0">  
               <value>郝佳</value>  
           </constructor-arg>  
           <constructor-arg index="1">  
               <value>你好</value>  
           </constructor-arg>  
       </bean>  
   ~~~

   > 郝佳为《Spring源码深度解析》作者

   对于constructor-arg子元素的解析，Spring是通过parseConstructorArgElements函数来实现的，具体的代码如下：

   ```java
       public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
         NodeList nl = beanEle.getChildNodes();
         for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
   //          解析constructor-arg
               parseConstructorArgElement((Element) node, bd);
            }
         }
      }
   ```

   parseConstructorArgElement:

   ~~~java
   	public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
   //		提取index属性
   		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
   //		提取type属性
   		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
   //		提取name属性
   		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
   		if (StringUtils.hasLength(indexAttr)) {
   			try {
   				int index = Integer.parseInt(indexAttr);
   				if (index < 0) {
   					error("'index' cannot be lower than 0", ele);
   				}
   				else {
   					try {
   						this.parseState.push(new ConstructorArgumentEntry(index));
   //						解析ele对应的属性元素
   						Object value = parsePropertyValue(ele, bd, null);
   						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
   						if (StringUtils.hasLength(typeAttr)) {
   							valueHolder.setType(typeAttr);
   						}
   						if (StringUtils.hasLength(nameAttr)) {
   							valueHolder.setName(nameAttr);
   						}
   						valueHolder.setSource(extractSource(ele));
   //						不允许重复指定相同参数
   						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
   							error("Ambiguous constructor-arg entries for index " + index, ele);
   						}
   						else {
   							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
   						}
   					}
   					finally {
   						this.parseState.pop();
   					}
   				}
   			}
   			catch (NumberFormatException ex) {
   				error("Attribute 'index' of tag 'constructor-arg' must be an integer", ele);
   			}
   		}
   		else {
   //			没有index属性则忽略，自动寻找
   			try {
   				this.parseState.push(new ConstructorArgumentEntry());
   				Object value = parsePropertyValue(ele, bd, null);
   				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
   				if (StringUtils.hasLength(typeAttr)) {
   					valueHolder.setType(typeAttr);
   				}
   				if (StringUtils.hasLength(nameAttr)) {
   					valueHolder.setName(nameAttr);
   				}
   				valueHolder.setSource(extractSource(ele));
   				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
   			}
   			finally {
   				this.parseState.pop();
   			}
   		}
   	}
   ~~~

   首先是提取constructor-arg上必要的属性（index、type、name）。

   - 如果配置中指定了index属性，那么操作步骤如下。

   1．解析Constructor-arg的子元素。

   2．使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。

   3．将type、name和index属性一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的indexedArgumentValues属性中。

   - 如果没有指定index属性，那么操作步骤如下。

   1．解析constructor-arg的子元素。

   2．使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。

   3．将type、name和index属性一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的genericArgumentValues属性中。

   可以看到，对于是否制定index属性来讲，Spring的处理流程是不同的，关键在于属性信息被保存的位置。

   那么了解了整个流程后，我们尝试着进一步了解解析构造函数配置中子元素的过程，进入parsePropertyValue

   ```java
       public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
         String elementName = (propertyName != null ?
               "<property> element for property '" + propertyName + "'" :
               "<constructor-arg> element");
   
         // Should only have one child element: ref, value, list, etc.
         NodeList nl = ele.getChildNodes();
         Element subElement = null;
         for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
   //       对应description或者meta不处理
            if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
                  !nodeNameEquals(node, META_ELEMENT)) {
               // Child element is what we're looking for.
               if (subElement != null) {
                  error(elementName + " must not contain more than one sub-element", ele);
               }
               else {
                  subElement = (Element) node;
               }
            }
         }
   //    解析constructor-arg的ref属性
         boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
   //    解析constructor-arg的value属性
         boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
   //    保证constructor-arg上不存在 1：同时有ref和value属性；2：存在ref或value且又有子元素
         if ((hasRefAttribute && hasValueAttribute) ||
               ((hasRefAttribute || hasValueAttribute) && subElement != null)) {
            error(elementName +
                  " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
         }
   
         if (hasRefAttribute) {
   //       ref属性的处理，使用RuntimeBeanReference封装对应的ref名称
            String refName = ele.getAttribute(REF_ATTRIBUTE);
            if (!StringUtils.hasText(refName)) {
               error(elementName + " contains empty 'ref' attribute", ele);
            }
            RuntimeBeanReference ref = new RuntimeBeanReference(refName);
            ref.setSource(extractSource(ele));
            return ref;
         }
         else if (hasValueAttribute) {
   //       value属性处理，使用TypedStringValue封装
            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
            valueHolder.setSource(extractSource(ele));
            return valueHolder;
         }
         else if (subElement != null) {
   //       解析子元素
            return parsePropertySubElement(subElement, bd);
         }
         else {
            // Neither child element nor "ref" or "value" attribute found.
            error(elementName + " must specify a ref or value", ele);
            return null;
         }
      }
   ```

   从代码上来看，对构造函数中属性元素的解析，经历了以下几个过程。

   1．略过description或者meta。

   2．提取constructor-arg上的ref和value属性，以便于根据规则验证正确性，其规则为在constructor-arg上不存在以下情况。

   - 同时既有ref属性又有value属性。
   - 存在ref属性或者value属性且又有子元素。

   3．ref属性的处理。使用RuntimeBeanReference封装对应的ref名称，如：

   ```xml
   <constructor-arg ref="a" >
   ```

   4．value属性的处理。使用TypedStringValue封装，如：

   ```xml
   <constructor-arg value="a" >
   ```

   5．子元素的处理，如：

   ```xml
            <constructor-arg>   
               <map>   
                  <entry key="key" value="value" />
               </map>   
           </constructor-arg>
   ```

   而对于子元素的处理，例如这里提到的在构造函数中又嵌入了子元素map是怎么实现的呢？parsePropertySubElement中实现了对各种子元素的分类处理。

   

   ```java
   public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
      if (!isDefaultNamespace(ele)) {
         return parseNestedCustomElement(ele, bd);
      }
      else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
         BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
         if (nestedBd != null) {
            nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
         }
         return nestedBd;
      }
      else if (nodeNameEquals(ele, REF_ELEMENT)) {
         // A generic reference to any name of any bean.
         String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
         boolean toParent = false;
         if (!StringUtils.hasLength(refName)) {
            // A reference to the id of another bean in a parent context.
            refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
            toParent = true;
            if (!StringUtils.hasLength(refName)) {
               error("'bean' or 'parent' is required for <ref> element", ele);
               return null;
            }
         }
         if (!StringUtils.hasText(refName)) {
            error("<ref> element contains empty target attribute", ele);
            return null;
         }
         RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
         ref.setSource(extractSource(ele));
         return ref;
      }
      else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
         return parseIdRefElement(ele);
      }
      else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
         return parseValueElement(ele, defaultValueType);
      }
      else if (nodeNameEquals(ele, NULL_ELEMENT)) {
         // It's a distinguished null value. Let's wrap it in a TypedStringValue
         // object in order to preserve the source location.
         TypedStringValue nullHolder = new TypedStringValue(null);
         nullHolder.setSource(extractSource(ele));
         return nullHolder;
      }
      else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
         return parseArrayElement(ele, bd);
      }
      else if (nodeNameEquals(ele, LIST_ELEMENT)) {
         return parseListElement(ele, bd);
      }
      else if (nodeNameEquals(ele, SET_ELEMENT)) {
         return parseSetElement(ele, bd);
      }
      else if (nodeNameEquals(ele, MAP_ELEMENT)) {
         return parseMapElement(ele, bd);
      }
      else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
         return parsePropsElement(ele);
      }
      else {
         error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);
         return null;
      }
   }
   ```

7. 解析子元素property

   parsePropertyElement函数完成了对property属性的提取，property使用方式如下：

   ```xml
   <bean id="test" class="test.TestClass">
        <property name="testStr" value="aaa"/>
   </bean>
   ```

   或

   ~~~xml
   <bean id="a">
            <property name="p">
                <list>
                    <value>aa</value>
                    <value>bb</value>
                </list>
            </property>
   </bean>
   ~~~

   解析过程如下：

   ~~~java
   	public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
   		NodeList nl = beanEle.getChildNodes();
   		for (int i = 0; i < nl.getLength(); i++) {
   			Node node = nl.item(i);
   			if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {
   				parsePropertyElement((Element) node, bd);
   			}
   		}
   	}
   ~~~

   有了之前分析构造函数的经验，这个函数我们并不难理解，无非是提取所有property的子元素，然后调用parsePropertyElement处理，parsePropertyElement代码如下

   ~~~java
   	public void parsePropertyElement(Element ele, BeanDefinition bd) {
   //		获取配置元素中name值
   		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
   		if (!StringUtils.hasLength(propertyName)) {
   			error("Tag 'property' must have a 'name' attribute", ele);
   			return;
   		}
   		this.parseState.push(new PropertyEntry(propertyName));
   		try {
   //			不允许多次对同意属性配置
   			if (bd.getPropertyValues().contains(propertyName)) {
   				error("Multiple 'property' definitions for property '" + propertyName + "'", ele);
   				return;
   			}
   			Object val = parsePropertyValue(ele, bd, propertyName);
   			PropertyValue pv = new PropertyValue(propertyName, val);
   			parseMetaElements(ele, pv);
   			pv.setSource(extractSource(ele));
   			bd.getPropertyValues().addPropertyValue(pv);
   		}
   		finally {
   			this.parseState.pop();
   		}
   	}
   ~~~

   可以看到上面函数与构造函数注入方式不同的是将返回值使用PropertyValue进行封装，并记录在了BeanDefinition中的propertyValues属性中。

8. 解析子元素qualifier

   对于qualifier元素的获取，我们接触更多的是注解的形式，在使用Spring框架中进行自动注入时，Spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的Bean时，Spring容器将抛出BeanCreationException异常，并指出必须至少拥有一个匹配的Bean。

   ```xml
   <bean id="myTestBean" class="bean.MyTestBean">
       <qualifier type="org.Springframework.beans.factory.annotation.Qualifier" value="qf"/>
   </bean>
   ```

   过程与之前相似。

#### AbstractBeanDefinition

大部分的通用属性都保存在了AbstractBeanDefinition中，那么我们再次通过AbstractBeanDefinition的属性来回顾一下我们都解析了哪些对应的配置。

~~~java
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
         implements BeanDefinition, Cloneable {

//此处省略静态变量以及final常量

     /**
      * bean的作用范围,对应bean属性scope
      */
     private String scope = SCOPE_DEFAULT;

     /**
      * 是否是单例,来自bean属性scope
      */
     private boolean singleton = true;

     /**
      * 是否是原型,来自bean属性scope
      */
     private boolean prototype = false;

     /**
      * 是否是抽象，对应bean属性abstract
      */
     private boolean abstractFlag = false;

     /**
      * 是否延迟加载,对应bean属性lazy-init
      */
     private boolean lazyInit = false;

     /**
      * 自动注入模式,对应bean属性autowire
      */
     private int autowireMode = AUTOWIRE_NO;

     /**
      * 依赖检查，Spring 3.0后弃用这个属性
      */
     private int dependencyCheck = DEPENDENCY_CHECK_NONE;
     /**
      * 用来表示一个bean的实例化依靠另一个bean先实例化,对应bean属性depend-on
      */
     private String[] dependsOn;

     /**
      * autowire-candidate属性设置为false，这样容器在查找自动装配对象时，
      * 将不考虑该bean，即它不会被考虑作为其他bean自动装配的候选者，但是该bean本身还是可以使用自动装配来注入其他bean的。 
      *  对应bean属性autowire-candidate
      */
     private boolean autowireCandidate = true;

     /**
      * 自动装配时当出现多个bean候选者时，将作为首选者,对应bean属性primary
      */
     private boolean primary = false;

     /**
      * 用于记录Qualifier，对应子元素qualifier
      */
     private final Map<String, AutowireCandidateQualifier> qualifiers =
             new LinkedHashMap<String, AutowireCandidateQualifier>(0);

     /**
      * 允许访问非公开的构造器和方法，程序设置
      */
     private boolean nonPublicAccessAllowed = true;

     /**
      * 是否以一种宽松的模式解析构造函数，默认为true,
      * 如果为false,则在如下情况
      * interface ITest{}
      * class  ITestImpl implements ITest{};
      * class Main{
      *     Main(ITest i){}
      *     Main(ITestImpl i){}
      * }
      * 抛出异常，因为Spring无法准确定位哪个构造函数
      * 程序设置
      */
     private boolean lenientConstructorResolution = true;

     /**
      * 记录构造函数注入属性，对应bean属性constructor-arg
      */
     private ConstructorArgumentValues constructorArgumentValues;

     /**
      * 普通属性集合
      */
     private MutablePropertyValues propertyValues;

     /**
      * 方法重写的持有者 ,记录lookup-method、replaced-method元素
      */
     private MethodOverrides methodOverrides = new MethodOverrides();

     /**
      * 对应bean属性factory-bean，用法：
      * <bean id="instanceFactoryBean" class="example.chapter3.InstanceFactoryBean"/>
     * <bean id="currentTime" factory-bean="instanceFactoryBean" factory-method="   
createTime"/>

      */
     private String factoryBeanName;

     /**
      * 对应bean属性factory-method
      */
     private String factoryMethodName;

     /**
      * 初始化方法，对应bean属性init-method
      */
     private String initMethodName;

     /**
      * 销毁方法，对应bean属性destory-method
      */
     private String destroyMethodName;

     /**
      * 是否执行init-method，程序设置
      */
     private boolean enforceInitMethod = true;

     /**
      * 是否执行destory-method，程序设置
      */
     private boolean enforceDestroyMethod = true;

     /**
      * 是否是用户定义的而不是应用程序本身定义的,创建AOP时候为true，程序设置
      */
     private boolean synthetic = false;

     /**
      * 定义这个bean的应用 ，APPLICATION：用户，INFRASTRUCTURE：完全内部使用，与用户无关，SUPPORT：某些复杂配置的一部分
      * 程序设置
      */
     private int role = BeanDefinition.ROLE_APPLICATION;

     /**
      * bean的描述信息
      */
     private String description;
     /**
      * 这个bean定义的资源
      */
     private Resource resource;
//此处省略set/get方法
}
~~~

#### 解析默认标签中的自定义标签元素

回顾下默认标签解析函数的起始函数：

```java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
   if (bdHolder != null) {
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try {
         // Register the final decorated instance.
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error("Failed to register bean definition with name '" +
               bdHolder.getBeanName() + "'", ele, ex);
      }
      // Send registration event.
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   }
}
```

之前大部分篇幅都在描述

~~~java
BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
~~~

现在，要对

~~~java
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
~~~

进行描述，从语义上分析，这句代码指：如果需要的话就对beanDefinition进行装饰。

比如：

~~~xml
<bean id="test" class="test.MyClass">
             <mybean:user username="aaa"/>
     </bean>
~~~

当Spring的bean使用的是默认的标签配置，但是其中的子元素却使用了自定义的配置时，这句代码便会起作用了。

跟进代码：

```java
public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {
   return decorateBeanDefinitionIfRequired(ele, originalDef, null);
}
```

第三个参数是父类bean，当对某个嵌套配置进行分析时，这里需要传递父类beanDefinition。分析源码得知这里传递的参数其实是为了使用父类的scope属性，以备子类若没有设置scope时默认使用父类的属性，这里分析的是顶层配置，所以传递null。将第三个参数设置为空后进一步跟踪函数：

```java
    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
         Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

      BeanDefinitionHolder finalDefinition = originalDef;

      // Decorate based on custom attributes first.
      NamedNodeMap attributes = ele.getAttributes();
//    遍历所有的属性，看看是否有适用于修饰的属性
      for (int i = 0; i < attributes.getLength(); i++) {
         Node node = attributes.item(i);
         finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
      }

      // Decorate based on custom nested elements.
      NodeList children = ele.getChildNodes();
//    遍历所有的子节点，看看是否有适用于修饰的子元素
      for (int i = 0; i < children.getLength(); i++) {
         Node node = children.item(i);
         if (node.getNodeType() == Node.ELEMENT_NODE) {
            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
         }
      }
      return finalDefinition;
   }
```

进入decorateIfRequired

~~~java
	public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {
//		获取自定义标签的命名空间
		String namespaceUri = getNamespaceURI(node);
//		对于非默认标签进行修饰
		if (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {
//			根据命名空间找到对应的处理器
			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
			if (handler != null) {
				BeanDefinitionHolder decorated =
						handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
				if (decorated != null) {
//					进行修饰
					return decorated;
				}
			}
			else if (namespaceUri.startsWith("http://www.springframework.org/schema/")) {
				error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", node);
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe "xml:...".
				if (logger.isDebugEnabled()) {
					logger.debug("No Spring NamespaceHandler found for XML schema namespace [" + namespaceUri + "]");
				}
			}
		}
		return originalDef;
	}
~~~

首先获取属性或者元素的命名空间，以此来判断该元素或者属性是否适用于自定义标签的解析条件，找出自定义类型所对应的NamespaceHandler并进行进一步解析。

#### 注册解析的BeanDefinition

对于配置文件来说，解析、装饰均分析完成之后，便只剩下注册的工作了。

也就是processBeanDefinition函数中的

```java
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
```

的解析了。

```java
public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

   // Register bean definition under primary name.
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // Register aliases for bean name, if any.
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
```

可以看出，解析的beanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中，而对于beanDefinition的注册分成了两部分：通过beanName的注册以及通过别名的注册。

1.通过beanName注册BeanDefinition

```java
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
         throws BeanDefinitionStoreException {

      Assert.hasText(beanName, "Bean name must not be empty");
      Assert.notNull(beanDefinition, "BeanDefinition must not be null");

      if (beanDefinition instanceof AbstractBeanDefinition) {
         try {
//          注册前的最后一次校验，这次校验主要是对于AbstractBeanDefinition属性中的methodOverrides校验
//          校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法根本不存在
            ((AbstractBeanDefinition) beanDefinition).validate();
         }
         catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                  "Validation of bean definition failed", ex);
         }
      }

      BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
      if (existingDefinition != null) {
         if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
         }
         else if (existingDefinition.getRole() < beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (logger.isInfoEnabled()) {
               logger.info("Overriding user-defined bean definition for bean '" + beanName +
                     "' with a framework-generated bean definition: replacing [" +
                     existingDefinition + "] with [" + beanDefinition + "]");
            }
         }
         else if (!beanDefinition.equals(existingDefinition)) {
            if (logger.isDebugEnabled()) {
               logger.debug("Overriding bean definition for bean '" + beanName +
                     "' with a different definition: replacing [" + existingDefinition +
                     "] with [" + beanDefinition + "]");
            }
         }
         else {
            if (logger.isTraceEnabled()) {
               logger.trace("Overriding bean definition for bean '" + beanName +
                     "' with an equivalent definition: replacing [" + existingDefinition +
                     "] with [" + beanDefinition + "]");
            }
         }
         this.beanDefinitionMap.put(beanName, beanDefinition);
      }
      else {
         if (hasBeanCreationStarted()) {
//          beanDefinitionMap是全局变量，这里会发生并发访问的情况
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
               this.beanDefinitionMap.put(beanName, beanDefinition);
               List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
               updatedDefinitions.addAll(this.beanDefinitionNames);
               updatedDefinitions.add(beanName);
               this.beanDefinitionNames = updatedDefinitions;
               removeManualSingletonName(beanName);
            }
         }
         else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
         }
         this.frozenBeanDefinitionNames = null;
      }

      if (existingDefinition != null || containsSingleton(beanName)) {
         resetBeanDefinition(beanName);
      }
      else if (isConfigurationFrozen()) {
         clearByTypeCache();
      }
   }
```

主要进行了几个步骤。

1．对AbstractBeanDefinition的校验。在解析XML文件的时候我们提过校验，但是此校验非彼校验，之前的校验时针对于XML格式的校验，而此时的校验时针是对于AbstractBean- Definition的methodOverrides属性的。

2．对beanName已经注册的情况的处理。如果设置了不允许bean的覆盖，则需要抛出异常，否则直接覆盖。

3．加入map缓存。

4．清除解析之前留下的对应beanName的缓存。

2.通过别名注册BeanDefinition

```java
    public void registerAlias(String name, String alias) {
      Assert.hasText(name, "'name' must not be empty");
      Assert.hasText(alias, "'alias' must not be empty");
      synchronized (this.aliasMap) {
//       如果beanName和alias相同的话不记录alias，删除对应的alias
         if (alias.equals(name)) {
            this.aliasMap.remove(alias);
            if (logger.isDebugEnabled()) {
               logger.debug("Alias definition '" + alias + "' ignored since it points to same name");
            }
         }
         else {
            String registeredName = this.aliasMap.get(alias);
            if (registeredName != null) {
               if (registeredName.equals(name)) {
                  // An existing alias - no need to re-register
                  return;
               }
//             如果alias不允许被覆盖则抛出异常
               if (!allowAliasOverriding()) {
                  throw new IllegalStateException("Cannot define alias '" + alias + "' for name '" +
                        name + "': It is already registered for name '" + registeredName + "'.");
               }
               if (logger.isDebugEnabled()) {
                  logger.debug("Overriding alias '" + alias + "' definition for registered name '" +
                        registeredName + "' with new target name '" + name + "'");
               }
            }
//          当A->B存在时，若有A->C->B则抛出异常
            checkForAliasCircle(name, alias);
            this.aliasMap.put(alias, name);
            if (logger.isTraceEnabled()) {
               logger.trace("Alias definition '" + alias + "' registered for name '" + name + "'");
            }
         }
      }
   }
```

注册alias的步骤如下。

1．alias与beanName相同情况处理。若alias与beanName并名称相同则不需要处理并删除掉原有alias。

2．alias覆盖处理。若aliasName已经使用并已经指向了另一beanName则需要用户的设置进行处理。

3．alias循环检查。当A->B存在时，若再次出现A->C->B时候则会抛出异常。

4．注册alias。

#### 通知监听器解析及注册完成

```java
getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
```

目前Spring中并没有对此事件做任何逻辑处理。

### alias标签的解析

有时我们期望能在当前位置为那些在别处定义的bean引入别名。在XML配置文件中，可用单独的\<alias/>元素来完成bean别名的定义。如配置文件中定义了一个JavaBean：

```xml
<bean id="testBean" class="com.test"/>
```

要给这个JavaBean增加别名，以方便不同对象来调用。我们就可以直接使用bean标签中的name属性：

同样，Spring还有另外一种声明别名的方式

```xml
<bean id="testBean" class="com.test"/>
    <alias name="testBean" alias="testBean,testBean2"/>
```

考虑一个更为具体的例子，组件A在XML配置文件中定义了一个名为componentA的DataSource类型的bean，但组件B却想在其XML文件中以componentB命名来引用此bean。而且在主程序MyApp的XML配置文件中，希望以myApp的名字来引用此bean。最后容器加载3个XML文件来生成最终的ApplicationContext。在此情形下，可通过在配置文件中添加下列alias元素来实现：

```xml
<alias name="componentA" alias="componentB"/>
     <alias name="componentA" alias="myApp" />
```

现在再来深入分析下对于alias标签的解析过程

~~~java
	protected void processAliasRegistration(Element ele) {
//		获取beanName
		String name = ele.getAttribute(NAME_ATTRIBUTE);
//		获取alias
		String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
		boolean valid = true;
		if (!StringUtils.hasText(name)) {
			getReaderContext().error("Name must not be empty", ele);
			valid = false;
		}
		if (!StringUtils.hasText(alias)) {
			getReaderContext().error("Alias must not be empty", ele);
			valid = false;
		}
		if (valid) {
			try {
				getReaderContext().getRegistry().registerAlias(name, alias);
			}
			catch (Exception ex) {
				getReaderContext().error("Failed to register alias '" + alias +
						"' for bean with name '" + name + "'", ele, ex);
			}
//			别名注册后通知监听器做相应处理
			getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
		}
	}
~~~

### import标签的解析

```xml
<?xml version="1.0" encoding="gb2312"?>
<!DOCTYPE beans PUBLIC "-//Spring//DTD BEAN//EN" "http://www.springframework.org/dtd/  
Spring-beans.dtd"> 
<beans>

    <import resource="customerContext.xml" />
    <import resource="systemContext.xml" />
    ... ...

</beans>
```

使用import的方式导入有模块配置文件，以后若有新模块的加入，那就可以简单修改这个文件了。这样大大简化了配置后期维护的复杂度，并使配置模块化，易于管理。我们来看看Spring是如何解析import配置文件的。

```java
    protected void importBeanDefinitionResource(Element ele) {
//    获取resource属性
      String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
//    如果不存在resource属性则不做任何处理
      if (!StringUtils.hasText(location)) {
         getReaderContext().error("Resource location must not be empty", ele);
         return;
      }

      // Resolve system properties: e.g. "${user.dir}"
      location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

      Set<Resource> actualResources = new LinkedHashSet<>(4);

      // Discover whether the location is an absolute or relative URI
      boolean absoluteLocation = false;
      try {
         absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
      }
      catch (URISyntaxException ex) {
         // cannot convert to an URI, considering the location relative
         // unless it is the well-known Spring prefix "classpath*:"
      }

      // Absolute or relative?
//    绝对URI直接过呢句地址加载对应的配置文件
      if (absoluteLocation) {
         try {
            int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
            if (logger.isTraceEnabled()) {
               logger.trace("Imported " + importCount + " bean definitions from URL location [" + location + "]");
            }
         }
         catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                  "Failed to import bean definitions from URL location [" + location + "]", ele, ex);
         }
      }
      else {
         // No URL -> considering resource location as relative to the current file.
//       如果是相对的则根据相对地址计算出绝对地址
         try {
            int importCount;
//          Resource存在多个子类实现类如VfsResource、FileSystemResource等
//          每个resource的createRelative方式实现都不一样，所以这里先使用子类的方法尝试解析
            Resource relativeResource = getReaderContext().getResource().createRelative(location);
            if (relativeResource.exists()) {
               importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
               actualResources.add(relativeResource);
            }
            else {
//             如果解析不成功，则使用默认的解析器
               String baseLocation = getReaderContext().getResource().getURL().toString();
               importCount = getReaderContext().getReader().loadBeanDefinitions(
                     StringUtils.applyRelativePath(baseLocation, location), actualResources);
            }
            if (logger.isTraceEnabled()) {
               logger.trace("Imported " + importCount + " bean definitions from relative location [" + location + "]");
            }
         }
         catch (IOException ex) {
            getReaderContext().error("Failed to resolve current resource location", ele, ex);
         }
         catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                  "Failed to import bean definitions from relative location [" + location + "]", ele, ex);
         }
      }
//    解析后进行监听器激活处理
      Resource[] actResArray = actualResources.toArray(new Resource[0]);
      getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
   }
```

解析<import标签时，Spring进行解析的步骤大致如下。

1．获取resource属性所表示的路径。

2．解析路径中的系统属性，格式如“${user.dir}”。

3．判定location是绝对路径还是相对路径。

4．如果是绝对路径则递归调用bean的解析过程，进行另一次的解析。

5．如果是相对路径则计算出绝对路径并进行解析。

6．通知监听器，解析完成。

### 嵌入式beans标签的解析

对于嵌入式的beans标签，相信大家使用过或者至少接触过，非常类似于import标签所提供的功能，使用如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.Springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.Springframework.org/schema/beans http://www.Springframework. org/schema/beans/Spring-beans.xsd">
     <bean id="aa" class="test.aa"/>
     <beans>
     </beans>
</beans>
```

## 自定义标签的解析

重新回到

```java
    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
//    对beans的处理
      if (delegate.isDefaultNamespace(root)) {
         NodeList nl = root.getChildNodes();
         for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
               Element ele = (Element) node;
               if (delegate.isDefaultNamespace(ele)) {
//                对bean的处理
                  parseDefaultElement(ele, delegate);
               }
               else {
//                对bean的处理
                  delegate.parseCustomElement(ele);
               }
            }
         }
      }
      else {
         delegate.parseCustomElement(root);
      }
   }
```

### 自定义标签使用

没用过，跳过